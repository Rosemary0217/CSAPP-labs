**姓名：**  刘婧婷    
**学号：** 1120201050   

## 一、实验目的

本实验目的是帮助你理解cache对C语言程序性能的影响。

## 二、报告要求

本报告要求学生解释说明所提交的转置函数是如何针对三种矩阵大小进行了何种优化的，优化效果如何。欢迎你写出你尝试过的所有优化策略，比较它们的效果以及分析效果优劣的原因。

## 三、实现分析
由于参数$ s=5，E=1，b=5 $, 故1个cache中共有32个set，每个set有1行，每行容量32个字节，每个cache容量为$ 2 ^ {10} $字节，可容纳$ 2 ^ 8 $个int型数据。

#### 1. 针对$32 \times 32 (M=32, N=32)$的矩阵

**优化策略**
使用三层循环，使用8个临时变量将A中元素先存储起来，然后统一赋值给B数组。
```C
int a0, a1, a2, a3;
for (bi = 0; bi < M; bi += 4) 
    for (bj = 0; bj < N; bj += 8) 
        for (i = bi; i < bi + 8; i++) {
            /*每转移8个元素，A只需要读入一次, 一次复制一个cache line中的*/
            a0 = A[i][bj+0]; 
            a1 = A[i][bj+1]; 
            a2 = A[i][bj+2]; 
            a3 = A[i][bj+3];
            a4 = A[i][bj+4]; 
            a5 = A[i][bj+5]; 
            a6 = A[i][bj+6]; 
            a7 = A[i][bj+7]; 
            /*B也只需要读入一次，因为一次可以读入8行*/
            B[bj+0][i] = a0; 
            B[bj+1][i] = a1; 
            B[bj+2][i] = a2; 
            B[bj+3][i] = a3;
            B[bj+4][i] = a4; 
            B[bj+5][i] = a5; 
            B[bj+6][i] = a6; 
            B[bj+7][i] = a7; 
    }
```



**优化效果**
miss次数为287。

**原因分析**
当矩阵大小为$32 \times 32$时，cache一次性可容纳矩阵A或B中8行数据，一个cache行存储一行中的8个元素。若使用四层循环，或使用三层循环将A[i,j]一一赋值给B[j,i]，会导致A、B数组在cache中频繁换入、换出，因此在一次循环中尽可能充分地利用cache中数据。选择8是因为cache一次可以容纳B矩阵的8行。

### 2. 针对$64 \times 64 (M=64, N=64)$的矩阵

**优化策略**
仍然使用8个局部变量，每次仍从cache中读出一个cache line的A数组内容，但是由于cache一次只能存储矩阵中4行，在转移到B数组时，前4个元素可以直接转移，后4个元素先转移至B数组对应列后的第4列（此时的后4个元素位置已经是转置后的了），然后再将相应位置的数据
```C
int a0, a1, a2, a3, a4, a5, a6, a7;
int i, j, bi, bj;
for (bi = 0; bi < N; bi += 8) {
    for (bj = 0; bj < M; bj += 8) {
        // 仍然以8*8为单位
        for (i = bi; i < bi + 4; i++) {
            // a0~a8是A中同一行内容，在同一次cache读入，不会缺页
            a0 = A[i][bj]; a1 = A[i][bj+1]; a2 = A[i][bj+2]; a3 = A[i][bj+3];  
            a4 = A[i][bj+4]; a5 = A[i][bj+5]; a6 = A[i][bj+6]; a7 = A[i][bj+7];  
            // 正确位置
            B[bj][i] = a0; B[bj+1][i] = a1; B[bj+2][i] = a2; B[bj+3][i] = a3;    
            // 同4行，这一列的后面第4列，此过程B不会产生缺页          
            B[bj][i+4] = a4; B[bj+1][i+4] = a5; B[bj+2][i+4] = a6; B[bj+3][i+4] = a7;  
        }
        // 下4行左4列移动到刚才已转置但暂存的4*4块位置上，暂存的4*4块使用局部变量暂存
        for (j = bj; j < bj + 4; j++) {
            // 下4行的A值
            a0 = A[bi+4][j]; a1 = A[bi+5][j]; a2 = A[bi+6][j]; a3 = A[bi+7][j];  
            // 暂存在B中已转置的A右上角
            a4 = B[j][bi+4]; a5 = B[j][bi+5]; a6 = B[j][bi+6]; a7 = B[j][bi+7];  
            // A左下角
            B[j][bi+4] = a0; B[j][bi+5] = a1; B[j][bi+6] = a2; B[j][bi+7] = a3;        
            // 发生一次miss 
            B[j+4][bi] = a4; B[j+4][bi+1] = a5; B[j+4][bi+2] = a6; B[j+4][bi+3] = a7;  
        }
        // 下4行的右4列
        for (i = bi + 4; i < bi + 8; i++) {
            a0 = A[i][bj+4]; a1 = A[i][bj+5]; a2 = A[i][bj+6]; a3 = A[i][bj+7]; 
            B[bj+4][i] = a0; B[bj+5][i] = a1; B[bj+6][i] = a2; B[bj+7][i] = a3; 
        }
    }
}
```

**优化效果**
miss次数为1179。

**原因分析**
当矩阵大小为$64 \times 64$时，cache一次性可容纳矩阵A或B中4行数据，一个cache行存储一行中的8个元素。此时若像上一个部分中一样，一次只置换B中4行的值，会导致A中数据利用率降低，A产生缺页中断的次数上升，所以利用B中尚未利用的空间暂存本来在后4行的值，可减少缺页次数。




### 3. 针对$61 \times 67 (M=61, N=67)$的矩阵

**优化策略**
使用双层for循环，每次从A中读取9个数据，然后转置到B中。由于61不是9的倍数，在读取之前需要先判断A中这一行是否还有数据可以读，写入B中时也如此。
```C
int a0, a1, a2, a3, a4, a5, a6, a7, a8;
int bi, bj;
for (bj = 0; bj < M; bj += 9) {
    for (bi = 0; bi < N; bi++) {
        a0 = A[bi][bj];    a1 = A[bi][bj+1];  a2 = A[bi][bj+2];
        a3 = A[bi][bj+3];  a4 = A[bi][bj+4];  a5 = A[bi][bj+5];
        a6 = A[bi][bj+6];
        if (bj + 7 < M) {  // 61 % 9 = 7
            a7 = A[bi][bj+7];
            a8 = A[bi][bj+8];
        }    
        // 转置到B中
        B[bj][bi] = a0;    B[bj+1][bi] = a1;  B[bj+2][bi] = a2;
        B[bj+3][bi] = a3;  B[bj+4][bi] = a4;  B[bj+5][bi] = a5;
        B[bj+6][bi] = a6;
        if (bj + 7 < M) {
            B[bj+7][bi] = a7;
            B[bj+8][bi] = a8;
        }
    }
}
```
每次读取8个数据也可以在评测中达到满分，miss次数为1748，稍多于9个数据时。
```C
for (bj = 0; bj < M; bj += 8) {
    for (bi = 0; bi < N; bi++) {
        a0 = A[bi][bj];    a1 = A[bi][bj+1];  a2 = A[bi][bj+2];
        a3 = A[bi][bj+3];  a4 = A[bi][bj+4];  
        if (bj + 5 < M) {   // 61 % 8 = 5
            a5 = A[bi][bj+5];
            a6 = A[bi][bj+6];
        }    
        // 转置到B中
        B[bj][bi] = a0;    B[bj+1][bi] = a1;  B[bj+2][bi] = a2;
        B[bj+3][bi] = a3;  B[bj+4][bi] = a4;
        if (bj + 5 < M) {
            B[bj+5][bi] = a5;
            B[bj+6][bi] = a6;
        }
    }
}
```

**优化效果**
miss次数为1701。

**原因分析**
61作为一个素数，在12个局部变量的限制下无法一次性读入一行的数据，cache行号也无法与矩阵的行号恰好对应。61\*67的矩阵小于64\*64，且本题对miss次数的限制放宽，考虑直接使用双层循环进行转置，单次读取8或9个数据均可达到满分，miss数分别为1748和1701。

## 四、实验总结

本段实验的第二题设计非常精妙。起初我尝试依然用第一问的思路求解，结果超过了1300次miss，上网查询资料后才明白应该进一步将8\*8的矩阵进一步分解，充分利用B的空闲空间。实验的设计非常精妙，在这个过程中我对cache的工作机制有了更深的理解。

